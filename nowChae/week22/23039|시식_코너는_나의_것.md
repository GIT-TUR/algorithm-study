## 문제

가톨릭대학교 축제에 N개의 시식코너가 열렸다.

최대한 많은 양의 음식을 먹고 싶은 아리는 방문한 시식코너에 남아있는 가능한 모든 음식들을 먹으려 한다. 하지만 연속으로 3개의 시식코너를 방문하면 눈치가 보이기 때문에 이럴 경우 최소 1번은 시식을 하지 않고 시식코너를 지나가야 한다. 예를 들어 1번과 2번 시식코너에서 시식했으면 2번 연속으로 시식했기 때문에 3번 시식코너는 방문할 수 없다.

아리는 식욕에 비해 장이 약해 잘 체하기 때문에 연속해서 시식할 경우 연속된 시식코너 중 2번째 시식코너에서는 그 시식코너에서 제공하는 총 음식 개수의 1/2개밖에 먹지 못한다. 단 음식의 개수가 홀수일 경우 음식의 개수를 2로 나누었을 때 몫만큼의 음식만 먹을 수 있다.

올해 가톨릭대학교 축제에는 사람들이 많이 몰렸기 때문에 음식이 0개인 시식코너가 있을 수 있다. 축제에서 진행하는 총 시식코너의 개수와 각 시식코너에서 시식할 수 있는 음식의 개수가 주어졌을 때 아리가 먹을 수 있는 음식의 최대 개수를 구하여라.

### 문제 링크

https://www.acmicpc.net/problem/23029

---

## 해결 방법

**제한된 음식 개수에서 먹을 수 있는 음식의 최대 개수** > **DP**

dp 테이블에 i index의 음식을 먹을 때, 얼마나 먹느냐(j)에 따라 그때의 max 값을 저장했다.

- j = 0 : 음식을 먹지 않음
- j = 1 : 음식의 1/2만 먹음
- j = 2 : 음식을 먹음

< i = 0 일때를 미리 세팅해두고 >

- dp[0][0]의 경우 아무것도 안먹는 상황이므로 0
- dp[0][1]은 1/2 먹는 경우이지만, 처음이라서 항상 다 먹을 수 밖에 없어서 신경쓰지 않아도 되는 값(코드에는 1/2 세팅해줬음)
- dp[0][2]의 경우 다 먹는 상황이므로, corner[0]의 값을 저장

< 1 부터 N-1까지를 갱신해간다 >
j 값과 i-1일 때의 dp 값을 기준으로 테이블을 갱신해준다.

- j = 0 일때는 음식을 먹지 않는 상황이므로, i-1일 때 j가 0,1,2인 경우 중 max 값을 저장해주면 된다.
- j = 1 일때는 음식을 1/2 먹는 상황이므로, i-1일때 j가 1인 경우(음식을 완전히 먹은 경우)에 corner[i] // 2 를 더해준 값을 저장하면 된다.
- j = 2 일때는 음식을 완전히 먹는 상황이므로, i-1일 떄 j가 0인 경우(음식을 먹지 않은 경우)에 corner[i]를 더해준 값을 저장하면 된다.

N-1의 상황까지 dp 테이블을 채워주고, 최종적으로 i값이 N-1일 때 리스트 내에서 max 값을 출력해주면 된다.

> **점화식을 만들 수 있는 DP 문제 - for문 루프 활용**
>
> 너무 어렵다 ~~! ㅜㅜ
