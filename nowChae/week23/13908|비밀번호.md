## 문제

웅찬이는 근성이 대단한 도둑이다. 그래서 금고를 털 때, 모든 조합을 눌러본다. 예를 들어 비밀번호가 3글자 라는 사실을 알 때, 000, 001, 002, 003, … 998, 999의 모든 조합을 눌러본다. 그러나 웅찬이는 선견지명이 있어서 비밀번호에 어떤 숫자가 들어가는지 일부 알 수 있다. 예를 들어 3글자 비밀번호에 0이 들어감을 안다면 999 와 같이 0이 들어가지 않는 수는 가능성이 없다. 그러나 000, 012, 030과 같은 수는 가능하다. 비밀번호의 길이와 선견지명으로 알게된 비밀번호의 일부 숫자가 주어질 때, 모든 가능한 비밀번호의 개수를 출력하는 프로그램을 작성하시오.


### 문제 링크

https://www.acmicpc.net/problem/13908

---

## 해결 방법

> 백트래킹 문제였습니다. 

제시된 비밀번호 길이만큼 0-9까지의 중복 조합을 모두 구하고, 선견지명으로 알게된 번호가 무조건 포함되어있는 지 판단하도록 했습니다.
중복 조합을 구하는 데에서 백트래킹을 사용했습니다. 특정 값을 넣고 다시 backtracking 함수를 호출한 후 넣었던 값을 빼는 상황을 반복해주었습니다.
만약 비밀번호의 길이가 n이 되면, 해당 비밀번호들에 특정 값이 존재하는 지 판단하도록 했습니다. 

특정 값들이 비밀번호 조합에 모두 포함되어있어야 하므로, 하나라도 포함되지 않는 상황이라면 반복을 그만두고 return 하도록 해주었습니다.
>**< for-else문 >**
> 
> 해당 부분 구현하면서 for문과 else 조합을 처음 알게 되었습니다.
> for문과 else문을 조합하게 되면, for문에서 break가 발생하지 않고 모든 반복문을 통과할 경우 else이 실행되게 됩니다.
> 만약 for문에서 break가 동작하면 else문은 실행되지 않습니다. 
> ``` python
>        for p in in_number:
>            if p not in numbers:
>                break
>        else:
>            result += 1
>```
> 위의 코드를 보면, 선견지명으로 알게된 문자들이 존재하는지 여부를 판단하게 되는데, 
> 만약 선견지명 숫자들 중 비밀번호에 존재하지 않으면 break가 발동합니다.
> 우선 숫자들 중 비밀번호에 존재하지 않는 다는 것은 비밀번호일 가능성이 없다는 것을 의미하고, for문에서 break가 발생했기에 else가 실행되지 않으며 결과 값은 그대로 유지됩니다.
> 모든 숫자들이 `if p not in numbers`의 조건에 걸리지 않아서(모든 선견지명 숫자가 비밀번호에 존재)한다면 해당 값은 비밀번호일 가능성이 있다는 것이고, for문을 완벽히 수행했기에 else문이 실행되어 result + 1 이 동작하게 됩니다. 

