## 문제

피아노를 사랑하는 시은이는 매일 아침 피아노 체조를 한다. 시은이는 N개의 악보를 가지고 있으며, 1번부터 N번까지의 번호로 부른다. 각 악보는 1 이상 109 이하의 정수로 표현되는 난이도를 가지고 있다. 난이도를 나타내는 수가 클수록 어려운 악보이다. 1 ≤ x ≤ y ≤ N 을 만족하는 두 정수 x, y를 골라 x번부터 y번까지의 악보를 번호 순서대로 연주하는 것이 피아노 체조이다.

시은이는 피아노 체조를 할 때, 지금 연주하는 악보가 바로 다음에 연주할 악보보다 어렵다면 실수를 한다. 다시 말하자면, i(x ≤ i < y)번 악보의 난이도가 i + 1번 악보의 난이도보다 높다면 실수를 한다. 특히, 마지막으로 연주하는 y번 악보에선 절대 실수하지 않는다. 시은이는 오늘도 피아노 체조를 하기 위해 두 정수 x와 y를 골랐고, 문득 궁금한 것이 생겼다. 오늘 할 피아노 체조에서 실수하는 곡은 몇 개나 될까?

### 문제 링크

https://www.acmicpc.net/problem/21318

---

## 해결 방법

누적합을 사용해 푸는 문제였다.
처음에 for문을 두 번 사용해서 풀었는데, 시간 초과가 발생했다.

fault 리스트에 1부터 idx에 해당하는 값까지 누적해서 틀린 수를 저장한다.

```
[1, 2, 3, 3, 4, 1, 10, 8, 1] 예시를 기준으로 fault 리스트 값은
[0, 0, 0, 0, 1, 1,  2, 3, 3] 으로 누적된다. <= 해당 누적된 값을 사용

앞에서부터 (1, 1), (1, 2), (1, 3) ... (1, 9)
괄호 사이의 값에서의 실수 숫자를 저장해둔 것이다.
```

계산의 편의성을 위해서 index 값을 숫자 그대로 사용하기 위해 앞에 0을 임의로 추가해주고 어차피 마지막 악보는 계산에서 사용되지 않으므로 추가하지 않았다.

[1 3] 범위에서는 1, 2 악보의 실수 여부를 판단하면 된다.
따라서 (1, 2) 범위 에서의 실수를 출력해주면 된다.

- 계산의 편의를 위해서 index = 0 일때의 값을 0으로 추가해두었기에 fault[2] - fault[0]을 계산해주면 된다.

마찬가지로 [2 5] 범위에서는 (2, 4) 범위에 해당 하는 악보 실수 여부를 판단하면된다.

- (2, 4) 범위 계산을 위해서는 fault[4] - fault[1] 을 계산해주면된다.

> **따라서 규칙이 생기는데 [x y] 범위에 대한 값을 구하려면 fault[y-1] - fault[x-1]을 해주면 된다.**
