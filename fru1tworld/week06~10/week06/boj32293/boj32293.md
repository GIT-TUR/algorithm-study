## 문제

[32293](https://www.acmicpc.net/problem/32293)

## 해결 방법

BFS
A를 기준으로 변화를 하는데 이 A를 기준으로 queue에 넣고 ABB로 변환되었으면
ABB는 BA로 바뀔 수 있는데. 이런 경우 ABABB와 같은 형태라면 연쇄적으로 변화할 수 있으므로 prev[i], i, j, next[j] 에서 A를 기준으로 다시 검사해서 큐에 넣는다.
이 때 ABB는 A의 개수는 유지되고 B의 개수는 1개 감소한다는 사실을 알 수 있으므로
최대 변환 횟수는 N을 초과할 수 없다.
따라서 O(N)인 BFS를 사용할 수 있다.

### 처음 생각한 풀이
ABBBBB와 같은 경우 A앞에 위치한 B는 연속된 B의 수열 floor(B/2)만큼 A의 뒤로 위치할 수 있고 만약 그 뒤에 A가 존재한다면 
다시 floor(B/2)만큼 뒤로 이동한다 즉 B의 개수는 2씩 나눠떨어진다.
사실 A의 좌표값만으로 본다면 A[i]와 A[i+1]에 대해서 A[i+1] - A[i]는 B의 개수를 보장할 수 있는데 이러한 차이를 2씩 나눠서 전파하면 큰 숫자에 대해서도 문제를 해결할 수 있다. 
예외 사항으로 ABAB와 같은 즉 A[i]와 A[i+1]의 차이가 2인 경우는 연속된 수열을 구해서 A로 바뀌는 지점을 따로 계산한다면 
문자열의 길이가 충분하게 크고 좌표만 주어진 문제에 대해서도 해결할 수 있다. 
