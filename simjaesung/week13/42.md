### 문제
https://leetcode.com/problems/trapping-rain-water/description/

스택으로 풀이해야겠다고는 느낌이 왔는데 막상 구현하려니 모르겠더라구요.. 그래서 다른 블로그 글들을 참고했습니다.

저는 스택에 높이 값을 넣는 방식으로 접근했었는데, 인덱스를 넣는 방식으로 접근했어야했군요..!

인덱스를 넣을 경우 그렇게 된다면 두 막대기 사이의 거리를 구할 수 있게 됩니다.

### 풀이

- 스택이 비어있으면 넣어줍니다.
- 다음 막대기의 높이가 스택의 top 높이보다 작거나 같을 경우에도 넣어줍니다. (이러면 물이 고일 수 없습니다.)
- 다음 막대기의 높이가 스택의 top 높이보다 높을 경우에 아래 로직을 수행해줍니다.
    1. 현재 스택의 top에 있는 높이(h)를 꺼냅니다. 이는 물이 고일 수 있는 바닥 높이가 됩니다.
    2. 스택이 비어있다면 break합니다. (왼쪽 벽이 없으면 물이 고일 수 없기 때문)
    3. 물이 고이는 너비(d)를 계산
        - 현재 인덱스(i)에서 스택의 top 인덱스를 뺀 후 1을 빼줍니다.
        - (`i - stack.peek() - 1`)
    4. 물이 고이는 높이를 계산
        - 왼쪽 벽(stack.peek())과 오른쪽 벽(현재 위치 i)중 더 낮은 높이에서
        - 바닥 높이(h)를 뺀 값이 물이 고이는 높이가 됩니다
        - Math.min(height[stack.peek()], height[i]) - height[h]
    5. 고이는 물의 양은 너비(d) × 높이를 곱한 값입니다.
- 예시

    ```
    높이: [4,2,0,3,2,5]
    
    i=0: 스택=[0(4)]
    i=1: 스택=[0(4),1(2)]
    i=2: 스택=[0(4),1(2),2(0)]
    i=3: height[3]=3이 height[2]=0보다 크므로:
        - h=2(0) 꺼냄
        - d=1, 높이=min(2,3)-0=2
        - ans+=2
        다시 height[3]=3이 height[1]=2보다 크므로:
        - h=1(2) 꺼냄
        - d=1, 높이=min(4,3)-2=1
        - ans+=1
    ```


더 빠른 풀이로는 투포인터 방식이 있더군요.

배열에 시작값과 끝값을 포인터로 잡아 둘 중 낮은 지점보다 낮은 막대기 위에는 물이 고일 수 밖에 없으니 그 부분을 계산하는 로직이었습니다.