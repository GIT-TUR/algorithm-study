## 문제
연두는 
$N$개의 통에 초콜릿을 담아서, 초콜릿의 개수가 오름차순이 되도록 일렬로 배열해 놓는다. 즉, (
$1$번째 통의 초콜릿의 개수) 
$\le$ (
$2$번째 통의 초콜릿의 개수) 
$\le \dots \le$ (
$N$번째 통의 초콜릿의 개수)이다. 

효원이는 매일 조금씩 연두의 초콜릿을 몰래 뺏어 먹을 계획을 세우는 중이다. 연두는 매우 눈치가 없기 때문에, 하루에 한 번 다음의 전략을 사용해서 초콜릿을 먹는다면 절대 눈치채지 못할 것이다.

 
$K<i$인 
$i$를 골라, 
$i-K$번째 통에 있는 초콜릿의 개수와 똑같아질 때까지 
$i$번째 통에서 초콜릿을 꺼내 먹는다.
그 후 통을 재정렬한다. 즉, 초콜릿의 개수가 오름차순이 되도록 통을 재배치 한다.
효원이는 연두가 눈치채지 못하는 선에서 최대한 많이, 그리고 최대한 빨리 초콜릿을 먹어 치우고 싶다. 과연 몇 개나 먹을 수 있을까?

### 입력
첫 번째 줄에 통의 개수 
$N$과 
$K$가 주어진다. (
$1 \le K < N \le 2\,000$)

두 번째 줄에 초기에 
$i$번째 통에 들어있는 초콜릿의 개수 
$a_1, a_2, \dots, a_N$이 주어진다. (
$1 \le a_1 \le a_2 \le \dots \le a_N \le 2\,000$)

### 출력
연두에게 들키지 않으면서 먹을 수 있는 초콜릿의 최대 개수와, 그 개수의 초콜릿을 먹기 위해 필요한 최소 날짜를 출력한다.

## 문제 풀이

N개의 통에 초콜렛을 담는다. 초콜렛 개수가 오름차순이 되도록 일렬로 배열한다.
- K < i인 i를 골라 i-K번째 통에 있는 초콜렛 개수와 똑같아질 때까지 i번째 통에서 초콜렛을 먹는다.
- 그 후 통을 재정렬한다. (오름차순)
- 시간 제한 1초, 메모리 제한 1024MB
- N은 최대 2000, 통의 최대 초콜렛 개수 2000개
- return [먹을 수 있는 최대 초콜렛 개수, 초콜렛을 먹기 위해 필요한 최소 날짜]

-> 최대한 눈치 채지 못하는 선에서 많이 먹는다면 몇개나 먹을 수 있을까?
- K < i를 매번 골라야하는데, K보다 뒤에 있는 통에서 어떤 통을 골라서 먹어야하는가? 
- 결국 초콜렛을 먹다보면 같아지는 순간이 온다. 같아지는 수는 초콜렛 통에서 가장 작은 초콜렛이 담긴 통의 개수다.
- 가장 작은 초콜렛이 담긴 통의 초콜렛 개수에 맞춰야한다.
- k를 생각하지 않고 풀어도 풀이가 가능하다. ㅠㅠ

``` python
chocolate.sort()
min_chocolate = chocolate[0] 
max_count = 0
min_day = 0

for i in range(1, n):
  if chocolate[i] > min_chocolate:
    min_day += 1
    max_count += (chocolate[i]-min_chocolate)
```
- 초콜렛 배열 한 번 정렬해준다.
- n 길이 배열을 순회하며 가장 작은 초콜렛 보다 많은 애들을 작은 초콜렛에 맞춰준다. (실제로 바꿀 필요는 없다.)
- 차이를 계산해서 더해주기만 하면 된다.

> 간단하게 풀리는데 k라는 조건이 복잡하게 문제를 만들었다. ㅜㅜ