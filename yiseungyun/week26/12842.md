## 문제
영선이는 대전에 내려갔다 서울 오는 길에 튀김 소보루 n개를 사왔다. (1 ≤ n ≤ 100,000)

영선이가 SCCC 회원들에게 나누어 주기 위하여 001에 두고 잠깐 나갔다 온 사이에 온전한 튀김 소보루는 s개가 남아 있었다.(먹기 위해 집어 든 튀김소보루는 제외한다)

영선이가 자리를 비운 동안 001에는 m명이 있었고, 각 사람은 1부터 m번까지 번호가 매겨져 있다. 영선이는 평소에 SCCC 회원들과 식사를 자주해서 식사 속도를 알고 있다. 이를 바탕으로 튀김 소보루 1개를 먹는데 걸리는 시간을 유추할 수 있다.

영선이를 위해 이 정보들을 바탕으로 마지막으로 튀김 소보루를 집어 든 사람의 번호를 구하여라.

여러 사람이 동시에 소보루를 집는다면 번호가 작은 사람이 먼저 잡으며, 영선이가 떠나자 마자 바로 먹기를 시작한다.

예를 들어, 소보루를 먹는 시간이 1번은 1초, 2번은 3초, 3번은 5초에 하나씩 먹는다고 하고, 소보루는 1000개 있다고 하자.

1개가 줄었다면 1번 사람이 처음 빵을 집을 것이다.
2개가 줄었다면 2번 사람이 1번 사람이 집은 직후 처음 빵을 집을 것이다.
3개가 줄었다면 3번 사람이 2번 사람이 집은 직후 처음 빵을 집을 것이다.
4개가 줄었다면 1번 사람이 빵을 다 먹고, 2개째 빵을 집을 것이다.
5개가 줄었다면 1번 사람이 빵을 다 먹고, 3개째 빵을 집을 것이다.
6개가 줄었다면 1번 사람이 빵을 다 먹고, 4개째 빵을 집을 것이다.
7개가 줄었다면 2번 사람이 빵을 다 먹고 1번 사람이 집은 직후, 2개째 빵을 집을 것이다.
### 입력
첫 번째 줄에 n s 가 주어진다. n은 영선이가 사온 튀김 소보루의 개수이다.

s는 영선이가 돌아왔을 때 남아 있던 튀김 소보루의 개수이다. (0 ≤ s ≤ n-1)

두 번째 줄 에는 m (1 ≤ m ≤ 100,000) 이 주어지고 , 다음 m 개의 줄 에는 1번부터 m번까지의 사람이 한 개의 소보루를 먹는데 걸리는 시간 ti(초) 가 주어진다. (1 ≤ ti ≤ 1,000)

### 출력
마지막으로 소보루를 집어 든 사람의 번호를 출력한다.

## 문제 풀이
- 시간 제한 1초, 메모리 제한 512MB

### 문제 해석
- 온전한 튀김 소보루는 s개가 남아있다.
- 자리를 비운 동안 001에 m명이 있었고, 각 사람은 1에서 m까지 번호가 매겨져있었다.
- *마지막으로 튀김 소보루를 집어 든 사람의 번호를 구해야한다.
- n: 튀김 소보루 개수 (최대 10**5), s: 남아있는 소보루 개수
- m: 사람 수 (최대 10**5), 1~m의 사람이 한 소보루를 먹는 시간

> 낮은 번호부터 집어먹는다. 

시뮬레이션으로 작성했는데, 88% 쯤에서 시간초과가 발생했다.

``` python
eaten = 0
time = 0
last_eaten = 0

while eaten < n-s:
  for i in range(m):
    if time%times[i] == 0: # 현재 시간 % i번째 사람이 먹는 시간 간격 == 0 => 먹음
      eaten += 1
      if eaten >= n-s:
        last_eaten = i+1
        break
  time += 1

print(last_eaten)
```

시간을 1씩 증가시키며 해당 시간에 1~m의 사람이 소보루를 먹을 수 있는지 확인하며 기록한다.

> 이렇게 풀이했더니 시간 초과가 발생했다. 그래서 순차적으로 다 확인하지 않고 우선순위 큐로 처리해줬다.

```python
pq = [(0, i) for i in range(m)]
heapq.heapify(pq)

eaten = 0
last_eaten = 0

while eaten < n-s:
  time, person = heapq.heappop(pq)
  eaten += 1
  last_eaten = person+1
  heapq.heappush(pq, (time+times[person], person))

print(last_eaten)
```

뇌가 굳은거 같다. 요즘 문제가 잘 안 풀리는거 같다. ㅠㅠ