## 문제
철수는 한양대학교 도서관에서 책을 빌려놓고 까먹고 있다가 며칠 후 책을 반납해야 한다는 사실을 깨달았다. 남은 기간 동안 최대한 많은 페이지를 읽고 연체없이 반납하고 싶다.

빌린 책은 여러 챕터로 구성된 에세이집인데 챕터들은 서로 독립적이다. 즉, 어느 챕터를 읽기 위해 다른 챕터를 먼저 읽어야 할 필요가 없다. 철수는 중간에 관두는 것을 못견디는 성격이라, 한 챕터를 읽기 시작하면 끝까지 봐야한다. 

남은 기간 N일과, 책의 각 챕터 당 그 챕터를 전부 읽는데 소요되는 일 수와 페이지 수가 주어질 때, N일간 읽을 수 있는 최대 페이지 수를 구하는 프로그램을 작성하라.

### 입력
첫째 줄에 N(1 ≤ N ≤ 200)과 챕터의 수 M(1 ≤ M ≤ 20)이 주어진다. 둘째 줄부터 각 챕터 당 읽는데 소요되는 일 수와 페이지 수가 주어진다. 소요되는 일 수는 20보다 작거나 같은 자연수이고, 페이지 수는 300보다 작거나 같은 자연수이다.

### 출력
읽을 수 있는 최대 페이지 수를 출력한다.

## 문제 풀이
최대한 많은 페이지를 읽고 연체 없이 반납해야한다.

- 빌린 책은 여러 챕터로 되어있고, 독립적이다.
- 한 챕터를 읽으면 끝까지 읽어야한다.
- 남은 기간 N일과 책의 각 챕터 당 그 챕터를 전부 읽는데 소요되는 일 수/페이지 수가 주어진다.

> N일 간 읽을 수 있는 최대 페이지 수를 구해야한다.

1일 당 읽을 수 있는 페이지 수를 기준으로 내림차순 정렬한다. 그리고 만약 이 값이 같은 경우는? 일수가 더 큰 쪽을 먼저 정렬하게 한다.
- 일수가 더 큰쪽을 택하는 이유는? 해당 일수가 더 많으므로 선택된다면 값이 더 크기 때문이다.
- 이렇게 풀었는데 틀렸다. 췽..

N = 1일때 최댓값은? 얼마인지 저장해가며 DP로 풀어보기로 했다.

- 2차원 DP로 풀면 풀리지만 1차원으로도 가능하다. 
- 대신 역순으로 챕터 반복문 내에서 i = N일 때부터 감소시키며 해당 챕터를 선택하거나 하지 않을 때 최대를 구해야한다.

```
for (const [d, page] of books) {
  for (let i = N; i > 0; i--) {
    if (i-d >= 0) DP[i] = Math.max(DP[i], DP[i-d]+page); 
  }
}
```
- 이렇게 구해야하는데, 역순이 아닌 1일부터 N까지의 순서로 해당 챕터를 넣을지 안넣을지 계산하게 되면 반복적으로 들어가게 된다.
- 역순이 아닌 방향으로 하면 1일부터 N일까지 매번 챕터에 대해 검사하는데, 해당 챕터를 만약 DP[a]에 넣어주면 뒤에 DP[i+a]를 할 때 중복되어 들어갈 수 있다. (중복 검사를 안하므로)
- 그런데 역순으로 하게 되면 N일차에 해당 챕터를 넣어주면, DP 앞 부분은 해당 챕터를 넣지 않은 초기화 상태이므로 넣지 않은 상태가 보장되어있다. 그러므로 중복이 발생하지 않는다.
