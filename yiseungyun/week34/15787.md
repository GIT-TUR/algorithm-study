## 문제
N개의 기차가 어둠을 헤치고 은하수를 건너려고 한다.

기차는 20개의 일렬로 된 좌석이 있고, 한 개의 좌석에는 한 명의 사람이 탈 수 있다. 

기차의 번호를 1번부터 N번으로 매길 때, 어떠한 기차에 대하여 M개의 명령이 주어진다.

명령의 종류는 4가지로 다음과 같다.

1 i x : i번째 기차에(1 ≤ i ≤ N) x번째 좌석에(1 ≤ x ≤ 20) 사람을 태워라. 이미 사람이 타있다면 , 아무런 행동을 하지 않는다.
2 i x : i번째 기차에 x번째 좌석에 앉은 사람은 하차한다. 만약 아무도 그자리에 앉아있지 않았다면, 아무런 행동을 하지 않는다.
3 i : i번째 기차에 앉아있는 승객들이 모두 한칸씩 뒤로간다. k번째 앉은 사람은 k+1번째로 이동하여 앉는다. 만약 20번째 자리에 사람이 앉아있었다면 그 사람은 이 명령 후에 하차한다.
4 i : i번째 기차에 앉아있는 승객들이 모두 한칸씩 앞으로간다. k번째 앉은 사람은 k-1 번째 자리로 이동하여 앉는다. 만약 1번째 자리에 사람이 앉아있었다면 그 사람은 이 명령 후에 하차한다.
M번의 명령 후에 1번째 기차부터 순서대로 한 기차씩 은하수를 건너는데 조건이 있다.

기차는 순서대로 지나가며 기차가 지나갈 때 승객이 앉은 상태를 목록에 기록하며 이미 목록에 존재하는 기록이라면 해당 기차는 은하수를 건널 수 없다.

예를 들면, 다음 그림을 예로 들었을 때, 1번째 기차와 같이 승객이 앉은 상태는 기록되지 않았기 때문에 은하수를 건널 수있다. 2번째 기차와 같은 상태도 기록되지 않았기 때문에 2번째 기차도 은하수를 건널 수 있다. 3번째 기차는 1번째 기차와 승객이 앉은 상태가 같으므로 은하수를 건널 수 없다.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15787/1.png)

처음에 주어지는 기차에는 아무도 사람이 타지 않는다.

은하수를 건널 수 있는 기차의 수를 출력하시오.

### 입력
입력의 첫째 줄에 기차의 수 N(1 ≤ N ≤ 100000)과 명령의 수 M(1 ≤ M ≤ 100000)가 주어진다. 이후 두 번째 줄부터 M+1번째 줄까지 각 줄에 명령이 주어진다. 

### 출력
은하수를 건널 수 있는 기차의 수를 출력하시오.

## 문제 풀이
N개의 기차가 은하수를 건넌다.
- 기차에는 20개의 일렬로 된 좌석이 있고, 한 좌석에 한 사람만 탈 수 있다.
- 기차 번호는 1~N으로 매기고, 어떠한 기차에 대해 M개 명령이 주어진다.
- 명령의 종류는 4가지
  - 1 i x: i번째 기차에 x번째 좌석에 사람을 태운다. 이미 타있으면 X
  - 2 i x: i번째 기차에서 x번째 좌석 사람은 하차한다. 없으면 X
  - 3 i: i번째 기차에 있는 사람들이 모두 한 칸씩 뒤로, 맨 끝 사람은 하차
  - 4 i: i번째 기차에 있는 사람이 모두 한 칸씩 앞으로, 맨 앞 사람은 하차

명령 후 1번째 기차부터 순서대로 한 기차씩 은하수를 건너는데 조건이 있다.
- 기차는 순서대로 지나감 -> 지나갈 때 승객 앉은 상태 기록 -> 이미 목록에 있으면 해당 기차는 건널 수 X
- 즉, 이전 기차와 똑같이 되어있으면 지나가지 못한다.

**조건**
- N(기차 수) <= 10**6
- M(명령 수) <= 10**6
- 시간 제한 1초, 메모리 제한 512MB

> 처음에 주어지는 기차에 아무도 타지 않는다.

각 기차마다 탄 사람이 어디 위치하는지 기록하기 위해, 각 기차별로 앉은 사람을 저장할 때 배열이 아닌 값으로 저장한다.
> 이 때 값은 이진수로 표현해줄 수 있다.

- 1 i x: i번째 기차에 x 좌석 => 사람을 태운다.
  - 원래 기차와 x번째 1로 설정한 것을 or 연산한다.
- 2 i x: i번째 기차에 x 좌석 => 사람을 하차시킨다.
  - 원래 기차와 x번째에 1로 설정한 것을 xor 연산한다.
- 3 i: i번째 기차를 >>한다.
- 4 i: i번째 기차를 <<한다.

> 비트마스킹을 사용해 기차마다 좌석 상태를 저장한다.

```javascript
for (let 명령 of command) {
  let [번호, ...기차] = 명령.split(" ").map(Number);
  if (번호 === 1) {
    train[기차[0]-1] |= 2**(20-기차[1]);
  } else if (번호 === 2) {
    train[기차[0]-1] &= ~(2**(20-기차[1]));
  } else if (번호 === 3) {
    train[기차[0]-1] >>= 1;
  } else {
    train[기차[0]-1] = (train[기차[0]-1] << 1) & ((1 << 20) - 1);
  }
}
```

- 1번 명령 -> 탑승 좌석 1로 하고 or 연산
- 2번 명령 -> 하차 좌석 1로 만든걸 not 연산을 통해 반대로 만들어서 and 연산
- 3번 명령 -> 1칸 뒤로
- 4번 명령 -> 1칸 앞으로하고 20칸 넘으면 그 부분은 저장 X
