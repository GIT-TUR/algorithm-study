## 42. Trapping Rain Water

Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.


Example 1:
![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)

Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
Example 2:

Input: height = [4,2,0,3,2,5]
Output: 9

## 문제 풀이
- 빗물이 채워지는 부분은 양 옆의 막대 중 낮은 것을 기준으로 채워진다. 

### 풀이 방법 생각하기
각 위치에서 양 옆에 높은 막대를 구하면 된다. 
  - 그렇다면 왼쪽으로 이동해서 기록하고, 오른쪽으로 이동하며 최댓값을 기록할 수 있다.
  - 예시에서 i = 2일 때 최대를 구하기 위해서 살펴보면 i = 2를 기준으로 왼쪽에서 가장 높은 막대는 1이고, 오른쪽에서는 3이된다. 
  - i = 2에서 채워지는 물의 양은 낮은 높이만큼이므로 1이되는 것이다.

이렇게 풀이하면 왼쪽에서의 최대 높이, 오른쪽에서의 최대 높이를 구해줘야한다.
> 더 간단하게 구할 방법은 없을지 생각을 했다.

- 각 위치에서는 왼쪽/오른쪽에서의 최댓값이 필요하다. 
- 왼쪽/오른쪽에 포인터를 둔다.
  - 예시로 이해해보았다.
  - 왼쪽 포인터는 인덱스 0을 가리키고 오른쪽은 인덱스 11을 가리킨다. 이때 왼쪽의 최댓값 = 0, 오른쪽의 최댓값 = 1이다.
  - 둘 중 최댓값이 작은 곳을 이동시킨다. 즉, 왼쪽을 이동시켜야한다.
> ✨ 둘 중 최댓값이 작은 곳을 이동시키는 이유
> i 위치에서 물이 채워지는 양을 구할 때 왼쪽의 최댓값과 오른쪽의 최댓값 중 작은 값을 기준으로 구한다.
> 즉 양쪽 중 작은 값을 알아야한다. 그런데 왼쪽의 최댓값과 오른쪽의 최댓값을 구하고 있는데 왼쪽 < 오른쪽이라면, 왼쪽의 높이가 물의 양이 된다.
> 그런데 왼쪽의 최댓값이 이것보다 클 수 있다. 그런데 오른쪽의 최댓값은 이것보다 더 크다면? 그럼에도 왼쪽 값을 사용하게 되기 때문에 찾는게 의미가 없다.
> a(왼) < b(오)인 상황에서 b가 더 커져도 어차피 a만 사용한다. 그런데 a < b인 상황에서 a를 사용하는데 a가 최댓값이 아니라면 이건 답이 달라진다.
> 그렇기 때문에 작은 곳을 이동시키는 것이다.

- 위와 같이 포인터를 최댓값이 더 작은 곳을 이동시키며 최댓값을 업데이트한다.
- 그 과정에서 각 위치에서 양 옆의 최댓값 중 작은 값을 골라 채워지는 물의 양을 구해주면 답이 나온다. 
