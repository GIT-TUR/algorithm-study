## 문제
민겸이는 크림 파스타를 먹다가 다음과 같은 문제를 생각해냈다.

빈 배열 
\(A\)가 있다. 민겸이는 
\(A\)의 맨 뒤에 정수를 
\(N\)번 추가하려고 한다. 수를 그냥 추가하기만 하면 재미없으니, 수를 추가할 때마다 1 ≤ 
\(i\) ≤ 
\(j\) ≤ 
\(|A|\) 를 만족하는 정수 
\(i\), 
\(j\)에 대하여 
\(A_j - A_i\)의 최댓값을 구하려고 한다. 
\(|A|\)는 배열 
\(A\)의 현재 길이를 뜻하고, 
\(A_i\)는 민겸이가 
\(i\)번째로 추가한 정수를 뜻한다.

민겸이가 식사를 마치기 전에 이 문제를 대신 풀어보자.

### 입력
입력은 두 줄로 주어진다.

첫 번째 줄에는 민겸이가 배열에 추가하려는 정수의 개수 
\(N\)이 주어진다.

두 번째 줄에는 
\(A_1\)부터 
\(A_N\)까지 
\(N\)개의 정수가 공백으로 구분되어 주어진다.

### 출력
각 
\(A_i\)가 추가된 직후의 문제의 답 
\(N\)개를 공백으로 구분하여 출력한다.

## 문제 풀이

> 빈 배열 A가 있고, A의 맨 뒤에 정수를 N번 추가한다. 추가할 때마다 1 <= i <= j <= |A|를 만족하는 i, j에 대하여 Aj-Ai의 최댓값을 구하려한다.

```
6
50 100 70 110 10 100
```

6개의 정수가 추가되는 예시로 풀어본다.

- 처음 50이 추가 되면, Aj-Ai의 최댓값은 0이 된다.
  - 아무 것도 없는 배열에 [50]이 되고 여기서 뽑을 수 있는 두 수는 50 뿐이라, 50-50 = 0이다.
- 100이 다음으로 추가 되면 [50, 100]으로 100-50이 최대가 된다.
- [50, 100, 70]이 되면 100-50이 여전히 최대가 된다.
- [50, 100, 70, 110]의 경우 110-50으로 60이 최대가 된다.
- [50, 100, 70, 110, 10]의 경우도 똑같다.
- [50, 100, 70, 110, 10, 100]의 경우는 100-10이 최대가 된다.

-> 매번 j와 i를 다 골라서 구하게 되면?
- j를 고르고, 1~j를 i로 설정해서 구해야한다.
- 이렇게 되면 N^2의 시간 복잡도가 나온다.
- N = 2*10^6이므로 시간 초과가 발생한다.

**어떻게 풀까**
- 먼저 맨 처음은 항상 0이 저장된다.
-> 맨 처음 수를 저장하기 전 빈 배열이고, 새로 들어오는 수가 최대이며 최소이기 때문이다.
- 두번째로 들어오는 수부터는 이전 값과 현재 위치의 값에서 최소를 뺄 때, 두 값을 비교해서 더 큰 값을 저장한다.
-> 이 과정에서 min에 최소 값이 갱신되면 저장해둔다.