## 문제
간선에 가중치와 방향성이 없는 임의의 루트 있는 트리가 주어졌을 때, 아래의 쿼리에 답해보도록 하자.

정점 U를 루트로 하는 서브트리에 속한 정점의 수를 출력한다.
만약 이 문제를 해결하는 데에 어려움이 있다면, 하단의 힌트에 첨부한 문서를 참고하자.

### 입력
트리의 정점의 수 N과 루트의 번호 R, 쿼리의 수 Q가 주어진다. (2 ≤ N ≤ 105, 1 ≤ R ≤ N, 1 ≤ Q ≤ 105)

이어 N-1줄에 걸쳐, U V의 형태로 트리에 속한 간선의 정보가 주어진다. (1 ≤ U, V ≤ N, U ≠ V)

이는 U와 V를 양 끝점으로 하는 간선이 트리에 속함을 의미한다.

이어 Q줄에 걸쳐, 문제에 설명한 U가 하나씩 주어진다. (1 ≤ U ≤ N)

입력으로 주어지는 트리는 항상 올바른 트리임이 보장된다.

### 출력
Q줄에 걸쳐 각 쿼리의 답을 정수 하나로 출력한다.

## 문제 풀이
가중치와 방향성이 없는 임의의 루트 있는 트리

- 정점 U를 루트로 하는 서브트리의 정점의 개수를 출력한다.
- 연결 정보를 저장해둔다. 양방향으로
- 루트부터 탐색하며 트리를 만들어간다.
- 각 배열에 바로 밑 자기 자식을 기록한다.
- 위 배열을 통해 각 정점의 서브트리 정점 개수를 구할 수 있다. (자기 자신 포함)

각 노드에서 서브 트리 정점 개수를 구하니까 메모리 초과가 났다. 그래서 매번 노드에 대해 자식을 탐색하는게 아닌 메모이제이션을 해야할 거 같았다.

- DP를 사용해야하는데 트리에서의 DP를 사용해본 적이 없어서 뭔가 이해가 안되었다.
- 찾아보니 트리에서의 DP는 DFS+DP를 사용해서 풀면 된다고 한다.

### 의사코드

> 간선의 방향이 없다. 즉, 양방향 다 저장해주고, 루트부터 탐색하면 서브트리가 무엇인지 알 수 있다.

- 간선 정보를 graph 배열에 graph[u] = [v], graph[v] = [u]와 같이 저장해준다.
- 루트부터 dfs를 해준다.
    - 방문한 노드는 자신을 포함해 count = 1을 해준다. 정점 한개를 가지고 있기 때문이다.
    - 그리고 자신의 자식을 탐색해서 자신의 자식의 서브트리 개수를 자신의 DP[자신] += 자식의 서브트리의 정점 수와 같이 저장해줘야한다.
    - 즉, dfs 함수는 node의 정점 개수를 반환해주는 형태여야한다.
    - 위와 같이 DP[node] = node를 루트로하는 서브트리의 정점 개수를 저장한다.
