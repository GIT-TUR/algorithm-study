## 문제
상근이는 컴퓨터 공학의 일인자가 되기 위해 책을 매우 많이 구매했다. 하지만, 집에 책장이 없어서 책을 탑처럼 쌓아놓고 있다.

오늘은 오랜만에 상근이가 집에서 휴식을 취하는 날이다. 상근이는 책을 알파벳 순서대로 정렬하려고 한다. 사전 순으로 가장 앞서는 책은 가장 위에 놓고, 가장 뒤에 있는 책은 가장 밑에 놓아야 한다. 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 뺀 다음, 가장 위에 놓는 것이다.

책은 1부터 N까지 번호가 책 이름의 사전 순으로 매겨져 있다. 1은 사전 순으로 가장 앞서는 책이다. 따라서, 위에서부터 책의 번호를 읽으면 (1, 2, ..., N)이 되어야 한다. 예를 들어, 책이 3권있고 처음에 (3, 2, 1)로 쌓여있을 때, 2번 만에 사전순으로 책을 쌓을 수 있다. 가장 먼저, 2번 책을 뺀 다음에 가장 위에 놓는다. 그렇게 되면 (2, 3, 1)이 된다. 마지막으로, 1을 뺀 다음 가장 위에 놓으면 (1, 2, 3)이 된다.

현재 책이 어떻게 쌓여있는지가 주어졌을 때, 몇 번만에 사전 순으로 쌓을 수 있는지 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 책의 개수 N이 주어진다. (N ≤ 300,000)

다음 N개 줄에는 가장 위에 있는 책부터 아래에 있는 책까지 순서대로 주어진다.

### 출력
첫째 줄에 몇 번만에 책을 정렬할 수 있는지 출력한다.

## 문제 풀이
책을 알파벳 순서로 정렬해서, 사전 순으로 앞서는 책은 가장 위에 놓고 가장 뒤에 있는 책은 가장 밑에 놓아야한다.
- 책을 정렬할 때 사용할 수 있는 방법은 책 하나를 빼고 가장 위에 놓는 것이다.
- 1~N까지의 번호는 사전 순으로 매겨져 있다. 1번이 사전 순으로 가장 앞선다. 즉, 가장 위에 놓여야한다.
- 최소로 움직여서 책을 사전 순으로 정렬하려면 어떻게 해야하는지 구해야한다.

### 어떻게 풀까?
{3, 2, 1}로 쌓여있다면 {1, 2, 3}으로 정렬해야한다.
- 그렇다면 2를 위로 올리고 1을 위로 올리면 2번 만에 사전 순 정렬이 된다. 
- 어떻게든 사전 순으로 정렬할 수 있겠지만 최소로 움직여서 정렬하려면 어떻게 해야할까? 췟.. 그러게..

예제 하나를 더 보면, 
```
4
1
3
4
2
```
- {1, 3, 4, 2} 순서로 있는데 이걸 최소로 움직여서 정렬하려면
- 2를 맨 앞으로 가져오고, 1을 다시 꺼내면 2번만에 정렬이 된다. 

맨 위로 가져와야하는 수는 정렬되지 않은 수다. 즉 {1, 3, 4, 2}에서 2가 순서에 맞지 않아서 꺼내준다. 
- {2, 1, 3, 4}가 되는데 이때 2, 1에서 1이 작으므로 다시 꺼내준다.
- 연속으로 잘 정렬된 부분만 건들지 않는다. 

예를 들어 예제와 다르게 하나 더 만들면 {1, 5, 6, 3, 2, 4}가 있다고 가정한다.
- 실제로 4 -> 3 -> 2 -> 1 순으로 옮기면 4번만에 정렬할 수 있다. 
- 이 케이스를 살펴보면 5, 6만 연속으로 잘 정렬되어 있다. 즉, 이 길이를 찾아 빼주면 옮겨야하는 수가 나온다.
- {1, 3, 4, 2}에서는 3, 4가 잘 정렬되어있고 이 길이는 2이므로 4-2가 옮겨야하는 숫자다.
- {3, 2, 1}은 3만 정렬되어 있으므로 3-1=2가 옮겨야하는 숫자다. 
- 위와 같은 방식으로 정렬되어 있는 것의 길이를 찾아야한다. (이때 정렬은 가장 큰 수까지 얼만큼 정렬되었는지가 기준이다.)

**조건**
- N은 최대 30만이며, 시간 제한은 1초다. 
- 즉 3*10**5이므로 N**2의 복잡도로는 풀 수 없다.
- N의 시간 복잡도로 풀면 좋을거 같다. 

### 잘못 생각했던 점
- N이 가장 큰 수고 이걸 포함하며 연속으로 1씩 증가하는 길이를 구해야한다 생각했다.
- 그런데 예외 케이스가 있었다. 길이가 6이고, 4 1 2 3 5 6이라면 내 생각대로면 6 - {5, 6의 길이 = 2} = 4개를 옮겨줘야한다.
- 하지만 위의 예시에서는 1, 2, 3만 위로 꺼내면 3번만에 정렬이 가능하다.
- 즉 가장 큰 N을 기준으로 1씩 작아지는 값이 연속으로 있을 필요가 없이 4, 5, 6의 길이를 구해야한다.

> 위 방식대로라면 풀이는 다음과 같다.
- 가장 큰 수 N을 찾는다. N부터 앞으로 오며 N보다 1 작은 수를 찾고, 찾으면 다음으로 1 더 작은 수를 계속해서 인덱스 0에 올 때까지 찾는다.
- 이 길이를 구해서 N에서 빼주면 옮겨야하는 최소 횟수가 나오는 것이다.