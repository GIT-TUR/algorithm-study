## 문제
영선이는 매우 기쁘기 때문에, 효빈이에게 스마일 이모티콘을 S개 보내려고 한다.

영선이는 이미 화면에 이모티콘 1개를 입력했다. 이제, 다음과 같은 3가지 연산만 사용해서 이모티콘을 S개 만들어 보려고 한다.

화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장한다.
클립보드에 있는 모든 이모티콘을 화면에 붙여넣기 한다.
화면에 있는 이모티콘 중 하나를 삭제한다.
모든 연산은 1초가 걸린다. 또, 클립보드에 이모티콘을 복사하면 이전에 클립보드에 있던 내용은 덮어쓰기가 된다. 클립보드가 비어있는 상태에는 붙여넣기를 할 수 없으며, 일부만 클립보드에 복사할 수는 없다. 또한, 클립보드에 있는 이모티콘 중 일부를 삭제할 수 없다. 화면에 이모티콘을 붙여넣기 하면, 클립보드에 있는 이모티콘의 개수가 화면에 추가된다.

영선이가 S개의 이모티콘을 화면에 만드는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 S (2 ≤ S ≤ 1000) 가 주어진다.

### 출력
첫째 줄에 이모티콘을 S개 만들기 위해 필요한 시간의 최솟값을 출력한다.

## 문제 풀이
이모티콘 S개를 보내려고 한다. 
- 이미 화면에 이모티콘 1개를 입력했다.
- 3가지 연산만 사용해 이모티콘 S개를 만든다.

1. 이모티콘 모두 복사해 클립보드 저장
2. 클립보드에 있는 이모티콘 붙여넣기
3. 화면에 있는 이모티콘 중 1개 삭제

모든 연산 1초가 걸린다.

> `S개 이모티콘을 만드는데 걸리는 시간의 최솟값`을 구해야한다.

- 2 <= S <= 1000
- 시간 제한 2초, 메모리 제한 512MB

### 어떻게 풀이할지

- BFS를 사용해서 풀이한다.

``` Python
while len(queue) > 0:
  screen, clipboard, time = queue.popleft()

  if screen == S:
    print(time)
    break

  if not visited[screen][screen]:
    visited[screen][screen] = True # 복사
    queue.append([screen, screen, time+1])

  if clipboard > 0 and screen + clipboard <= 1000 and not visited[screen+clipboard][clipboard]:
    visited[screen+clipboard][clipboard] = True
    queue.append([screen+clipboard, clipboard, time+1])
  
  if screen-1 >= 0 and not visited[screen-1][clipboard]:
    visited[screen-1][clipboard] = True
    queue.append([screen-1, clipboard, time+1])
```

- 현재 화면의 이모티콘 수와 클립보드에 복사된 이모티콘 수를 저장해야한다.
- 현재 화면에서 복사할지 붙여넣을지 하나를 지울지 3가지 동작을 수행해서 큐에 넣는다.

1. 복사할 때
- 현재 화면에 있는 수만큼 클립보드에 복사하므로
- 현재 화면의 수 screen이 있고, 복사하면 클립보드는 screen개만큼 있다. => 방문 표시를 해주고 큐에 넣는다.

2. 붙여넣을 때 
- 클립보드에 0개가 넘어갈 때 붙여넣기 동작이 가능하고,
- 1000까지 범위므로 그를 넘어가면 확인하지 않는다.
- 현재 화면에 있던 값 screen과 clipboard에 붙여넣은 값으로 화면 이모티콘 개수가 갱신된다.
- 클립보드에는 붙여 넣어도 그 값이 유지되므로 비울 필요가 없다.

3. 화면에 있는 값을 삭제하는 경우
- 현재 화면 screen 값에 1을 뺄 때 0 이상인 범위여야하고, 클립보드 개수는 그대로 변화가 없다.
